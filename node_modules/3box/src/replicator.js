const EventEmitter = require('events');
const OrbitDB = require('orbit-db')
const Pubsub = require('orbit-db-pubsub')
const AccessControllers = require('orbit-db-access-controllers')
const {
  LegacyIPFS3BoxAccessController,
  ThreadAccessController,
  ModeratorAccessController
} = require('3box-orbitdb-plugins')
AccessControllers.addAccessController({ AccessController: LegacyIPFS3BoxAccessController })
AccessControllers.addAccessController({ AccessController: ThreadAccessController })
AccessControllers.addAccessController({ AccessController: ModeratorAccessController })

const PINNING_NODE = config.pinning_node
const PINNING_ROOM = config.pinning_room
const ORBITDB_OPTS = config.orbitdb_options

class Replicator {

  constructor (ipfs, opts) {
    this.events = new EventEmitter()
    this.ipfs = ipfs
    this.pinningNode = opts.pinningNode || PINNING_NODE
    this.ipfs.swarm.connect(this.pinningNode, () => {})
    this._isSynced = {}
    this.hasPubsubMsgs = {}
    this.events.on('pinning-room-message', (topic, data) => {
      if (data.type === 'HAS_ENTRIES' && data.odbAddress) {
        odbAddress = data.odbAddress
        this.hasPubsubMsgs[odbAddress] = data
        this.events.emit(`has-${odbAddress}`, data)
      }
    })
  }

  async _init (opts) {
    this._pubsub = new Pubsub(this.ipfs, (await this.ipfs.id()).id)
    this.orbitdb = await OrbitDB.createInstance(this.ipfs, { directory: opts.orbitPath })
    this._pubsub.subscribe(PINNING_ROOM, (topic, data) => {
      console.log('message', topic, data)
      this.events.emit('pinning-room-message', topic, data)
    }, (topic, peer) => {
      console.log('peer', topic, peer)
      this.events.emit('pinning-room-peer', topic, peer)
    })
  }

  static async createInstance (ipfs, opts = {}) {
    const replicator = new Replicator(ipfs, opts)
    await replicator._init(opts)
    return replicator
  }

  async start (rootStoreAddress, opts = {}) {
    const rootEntriesPromise = this._getNumEntries(rootStoreAddress)
    this._publishDB(rootStoreAddress)

    this.rootstore = await this._orbitdb.feed(rootStoreAddress, {
      ...ORBITDB_OPTS,
      accessController: {
        type: 'legacy-ipfs-3box',
        skipManifest: true
      }
    })
    await this.rootstore.load()
    const waitForSync = async () => {
      const numEntries = await rootEntriesPromise
      await Replicator.syncDB(this.rootstore, numEntries)
      this.events.emit('sync-done-rootstore')
    }
  }



  loadSubStores ({ profile, allSpaces }) {
    const subStoreEntries = this.listSubStores()
    subStoreEntries.map(entry => {
      const data = entry.payload.value
      if (data.type === rootEntryTypes.SPACE && allSpaces) {
        // don't open db if the space entry is malformed
        if (!data.DID || !data.odbAddress) return
        pinDID(data.DID)
      }
      if (data.odbAddress.includes('public') || data.odbAddress.includes('private')) {
      }
    })
  }

  listSubStores () {
    const entries = this.rootstore.iterator({ limit: -1 }).collect().filter(e => Boolean(e.payload.value.odbAddress))
    const uniqueEntries = entries.filter((e1, i, a) => {
      return a.findIndex(e2 => e2.payload.value.odbAddress === e1.payload.value.odbAddress) === i
    })
    return uniqueEntries
  }

  isSynced (space) {
    if (!space) {
      return
    }
  }

  async _getNumEntries (odbAddress) {
    return new Promise((resolve, reject) => {
      const eventName = `has-${odbAddress}`
      this.events.on(eventName, data => {
        resolve(data.numEntries)
        this.events.removeAllListeners(eventName)
      })
      if (this.hasPubsubMsgs[odbAddress]) {
        resolve(this.hasPubsubMsgs[odbAddress].numEntries)
        this.events.removeAllListeners(eventName)
      }
    })
  }

  async _publishDB (rootStoreAddress, did) {
    // make sure that the pinning node is in the pubsub room before publishing
    const pinningNodeJoined = new Promise((resolve, reject) => {
      this.events.on('pinning-room-peer', (topic, peer) => {
        if (peer === this.pinningNode.split('/').pop()) {
          resolve()
        }
      })
    })
    if (!(await this.ipfs.pubsub.peers(PINNING_ROOM)).includes(this.pinningNode)) {
      await pinningNodeJoined
    }
    this._pubsub.publish(PINNING_ROOM, {
      type: 'PIN_DB',
      odbAddress: rootStoreAddress,
      did
    })
    this.events.removeAllListeners('pinning-room-peer')
  }

  static async syncDB (dbInstance, numRemoteEntries) {
    const numEntriesDefined = !(numRemoteEntries === null || numRemoteEntries === undefined)
    if (numEntriesDefined && numRemoteEntries <= dbInstance._oplog.values.length) return Promise.resolve()
    await new Promise((resolve, reject) => {
      if (!numRemoteEntries) {
        setTimeout(() => {
          dbInstance.events.removeAllListeners('replicated')
          dbInstance.events.removeAllListeners('replicate.progress')
          resolve()
        }, 3000)
      }
      dbInstance.events.on('replicated', () => {
        if (numRemoteEntries <= dbInstance._oplog.values.length) {
          resolve()
          dbInstance.events.removeAllListeners('replicated')
          dbInstance.events.removeAllListeners('replicate.progress')
        }
      })
    })
  }
}

