"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var localstorage = require('store');

var IPFS = require('ipfs');

var OrbitDB = require('orbit-db');

var Pubsub = require('orbit-db-pubsub'); // const OrbitDBCacheProxy = require('orbit-db-cache-postmsg-proxy').Client
// const { createProxyClient } = require('ipfs-postmsg-proxy')


var AccessControllers = require('orbit-db-access-controllers');

var _require = require('3box-orbitdb-plugins'),
    LegacyIPFS3BoxAccessController = _require.LegacyIPFS3BoxAccessController,
    ThreadAccessController = _require.ThreadAccessController,
    ModeratorAccessController = _require.ModeratorAccessController;

AccessControllers.addAccessController({
  AccessController: LegacyIPFS3BoxAccessController
});
AccessControllers.addAccessController({
  AccessController: ThreadAccessController
});
AccessControllers.addAccessController({
  AccessController: ModeratorAccessController
});

var ThreeId = require('./3id');

var PublicStore = require('./publicStore');

var PrivateStore = require('./privateStore');

var Verified = require('./verified');

var Space = require('./space');

var utils = require('./utils/index');

var idUtils = require('./utils/id');

var config = require('./config.js');

var API = require('./api');

var ACCOUNT_TYPES = {
  ethereum: 'ethereum',
  ethereumEOA: 'ethereum-eoa'
};
var ADDRESS_SERVER_URL = config.address_server_url;
var PINNING_NODE = config.pinning_node;
var PINNING_ROOM = config.pinning_room; // const IFRAME_STORE_VERSION = '0.0.3'
// const IFRAME_STORE_URL = `https://iframe.3box.io/${IFRAME_STORE_VERSION}/iframe.html`

var IPFS_OPTIONS = config.ipfs_options;
var ORBITDB_OPTS = config.orbitdb_options;
var globalIPFS, globalOrbitDB; // , ipfsProxy, cacheProxy, iframeLoadedPromise

/*
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  const iframe = document.createElement('iframe')
  iframe.src = IFRAME_STORE_URL
  iframe.style = 'width:0; height:0; border:0; border:none !important'

  iframeLoadedPromise = new Promise((resolve, reject) => {
    iframe.onload = () => { resolve() }
  })

  document.body.appendChild(iframe)
  // Create proxy clients that talks to the iframe
  const postMessage = iframe.contentWindow.postMessage.bind(iframe.contentWindow)
  ipfsProxy = createProxyClient({ postMessage })
  cacheProxy = OrbitDBCacheProxy({ postMessage })
} */

var Box =
/*#__PURE__*/
function () {
  /**
   * Please use the **openBox** method to instantiate a 3Box
   */
  function Box(threeId, ethereumProvider, ipfs) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, Box);
    this._3id = threeId;
    this._web3provider = ethereumProvider;
    this._ipfs = ipfs;
    this._serverUrl = opts.addressServer || ADDRESS_SERVER_URL;

    this._onSyncDoneCB = function () {};

    this._boxSynced = false;
    /**
     * @property {KeyValueStore} public         access the profile store of the users 3Box
     */

    this["public"] = null;
    /**
     * @property {KeyValueStore} private        access the private store of the users 3Box
     */

    this["private"] = null;
    /**
     * @property {Verified} verified        check and create verifications
     */

    this.verified = new Verified(this);
    /**
     * @property {Object} spaces            an object containing all open spaces indexed by their name.
     */

    this.spaces = {}; // local store of all pinning server pubsub messages seen related to spaces

    this.spacesPubSubMessages = {};
  }

  (0, _createClass2["default"])(Box, [{
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3() {
        var _this = this;

        var opts,
            rootStoreName,
            key,
            rootStoreAddress,
            onNewPeer,
            _ref2,
            _ref3,
            pubStoreAddress,
            privStoreAddress,
            syncPromises,
            hasResponse,
            spaceMessageFilterActive,
            filterTimeSet,
            onMessageRes,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                rootStoreName = this._3id.muportFingerprint + '.root';
                this.pinningNode = opts.pinningNode || PINNING_NODE;

                this._ipfs.swarm.connect(this.pinningNode, function () {});

                _context3.t0 = OrbitDB;
                _context3.t1 = this._ipfs;
                _context3.t2 = opts.orbitPath;
                _context3.next = 9;
                return this._3id.getOdbId();

              case 9:
                _context3.t3 = _context3.sent;
                _context3.t4 = {
                  directory: _context3.t2,
                  identity: _context3.t3
                };
                _context3.next = 13;
                return _context3.t0.createInstance.call(_context3.t0, _context3.t1, _context3.t4);

              case 13:
                this._orbitdb = _context3.sent;
                // , { cache })
                globalOrbitDB = this._orbitdb;
                key = this._3id.getKeyringBySpaceName(rootStoreName).getPublicKeys(true).signingKey;
                _context3.next = 18;
                return this._orbitdb.feed(rootStoreName, _objectSpread({}, ORBITDB_OPTS, {
                  format: 'dag-pb',
                  accessController: {
                    write: [key],
                    type: 'legacy-ipfs-3box',
                    skipManifest: true
                  }
                }));

              case 18:
                this._rootStore = _context3.sent;
                rootStoreAddress = this._rootStore.address.toString();
                _context3.t5 = Pubsub;
                _context3.t6 = this._ipfs;
                _context3.next = 24;
                return this._ipfs.id();

              case 24:
                _context3.t7 = _context3.sent.id;
                this._pubsub = new _context3.t5(_context3.t6, _context3.t7);

                onNewPeer =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee(topic, peer) {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (peer === _this.pinningNode.split('/').pop()) {
                              _this._pubsub.publish(PINNING_ROOM, {
                                type: 'PIN_DB',
                                odbAddress: rootStoreAddress,
                                did: _this.DID
                              });
                            }

                          case 1:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function onNewPeer(_x2, _x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                this["public"] = new PublicStore(this._orbitdb, this._3id.muportFingerprint + '.public', this._linkProfile.bind(this), this._ensurePinningNodeConnected.bind(this), this._3id);
                this["private"] = new PrivateStore(this._orbitdb, this._3id.muportFingerprint + '.private', this._ensurePinningNodeConnected.bind(this), this._3id);
                _context3.next = 31;
                return Promise.all([this["public"]._load(), this["private"]._load()]);

              case 31:
                _ref2 = _context3.sent;
                _ref3 = (0, _slicedToArray2["default"])(_ref2, 2);
                pubStoreAddress = _ref3[0];
                privStoreAddress = _ref3[1];
                syncPromises = [];
                hasResponse = {}; // Filters and store space related messages for 3secs, the best effort
                // simple approach, until refactor

                spaceMessageFilterActive = true;
                filterTimeSet = false;

                onMessageRes =
                /*#__PURE__*/
                function () {
                  var _ref4 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee2(topic, data) {
                    var promises;
                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!filterTimeSet) {
                              filterTimeSet = true;
                              setTimeout(function () {
                                spaceMessageFilterActive = false;
                              }, 3000);
                            }

                            if (!(data.type === 'HAS_ENTRIES')) {
                              _context2.next = 12;
                              break;
                            }

                            if (data.odbAddress === privStoreAddress && !hasResponse[privStoreAddress]) {
                              syncPromises.push(_this["private"]._sync(data.numEntries));
                              hasResponse[privStoreAddress] = true;
                            }

                            if (data.odbAddress === pubStoreAddress && !hasResponse[pubStoreAddress]) {
                              syncPromises.push(_this["public"]._sync(data.numEntries));
                              hasResponse[pubStoreAddress] = true;
                            }

                            if (spaceMessageFilterActive && data.odbAddress.includes('space') === true) {
                              _this.spacesPubSubMessages[data.odbAddress] = data;
                            }

                            if (!(syncPromises.length === 2)) {
                              _context2.next = 12;
                              break;
                            }

                            promises = syncPromises;
                            syncPromises = [];
                            _context2.next = 10;
                            return Promise.all(promises);

                          case 10:
                            _this._boxSynced = true;

                            _this._onSyncDoneCB(); // this._pubsub.unsubscribe(PINNING_ROOM)


                          case 12:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function onMessageRes(_x4, _x5) {
                    return _ref4.apply(this, arguments);
                  };
                }();

                this._pubsub.subscribe(PINNING_ROOM, onMessageRes, onNewPeer);

                _context3.next = 43;
                return this._createRootStore(rootStoreAddress, privStoreAddress, pubStoreAddress, this.pinningNode);

              case 43:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _load() {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_createRootStore",
    value: function () {
      var _createRootStore2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(rootStoreAddress, privOdbAddress, pubOdbAddress) {
        var _this2 = this;

        var entries, pinAddressLinks;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._rootStore.load();

              case 2:
                _context5.next = 4;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 4:
                entries = _context5.sent;

                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === pubOdbAddress;
                })) {
                  _context5.next = 8;
                  break;
                }

                _context5.next = 8;
                return this._rootStore.add({
                  odbAddress: pubOdbAddress
                });

              case 8:
                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === privOdbAddress;
                })) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 11;
                return this._rootStore.add({
                  odbAddress: privOdbAddress
                });

              case 11:
                this._publishRootStore(rootStoreAddress);

                pinAddressLinks =
                /*#__PURE__*/
                function () {
                  var _ref5 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee4() {
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            // Filter for address-links, get CID, and get to pin it
                            entries.filter(function (entry) {
                              return entry.payload.value.type === 'address-link';
                            }).map(function (entry) {
                              _this2._ipfs.dag.get(entry.payload.value.data);
                            });

                          case 1:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function pinAddressLinks() {
                    return _ref5.apply(this, arguments);
                  };
                }();

                pinAddressLinks();

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _createRootStore(_x6, _x7, _x8) {
        return _createRootStore2.apply(this, arguments);
      }

      return _createRootStore;
    }()
    /**
     * Get the public profile of a given address
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.addressServer      URL of the Address Server
     * @param     {Object}    opts.ipfs               A js-ipfs ipfs object
     * @param     {Boolean}   opts.useCacheService    Use 3Box API and Cache Service to fetch profile instead of OrbitDB. Default true.
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the profile for the given address
     */

  }, {
    key: "openSpace",

    /**
     * Opens the space with the given name in the users 3Box
     *
     * @param     {String}            name                    The name of the space
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {Function}          opts.onSyncDone         A function that will be called when the space has finished syncing with the pinning node
     * @return    {Space}                                     the Space instance for the given space name
     */
    value: function () {
      var _openSpace = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(name) {
        var opts,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};

                if (this.spaces[name]) {
                  _context6.next = 23;
                  break;
                }

                this.spaces[name] = new Space(name, this._3id, this._orbitdb, this._rootStore, this._ensurePinningNodeConnected.bind(this));
                _context6.prev = 3;
                opts = Object.assign({
                  numEntriesMessages: this.spacesPubSubMessages
                }, opts);
                _context6.next = 7;
                return this.spaces[name].open(opts);

              case 7:
                _context6.next = 9;
                return this.isAddressLinked();

              case 9:
                if (_context6.sent) {
                  _context6.next = 11;
                  break;
                }

                this.linkAddress();

              case 11:
                _context6.next = 21;
                break;

              case 13:
                _context6.prev = 13;
                _context6.t0 = _context6["catch"](3);
                delete this.spaces[name];

                if (!_context6.t0.message.includes('User denied message signature.')) {
                  _context6.next = 20;
                  break;
                }

                throw new Error('User denied space consent.');

              case 20:
                throw new Error('An error occured while opening space: ', _context6.t0.message);

              case 21:
                _context6.next = 24;
                break;

              case 23:
                if (opts.onSyncDone) {
                  // since the space is already open we can call onSyncDone directly
                  opts.onSyncDone();
                }

              case 24:
                return _context6.abrupt("return", this.spaces[name]);

              case 25:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[3, 13]]);
      }));

      function openSpace(_x9) {
        return _openSpace.apply(this, arguments);
      }

      return openSpace;
    }()
    /**
     * Sets the callback function that will be called once when the db is fully synced.
     *
     * @param     {Function}      syncDone        The function that will be called
     */

  }, {
    key: "onSyncDone",
    value: function onSyncDone(syncDone) {
      this._onSyncDoneCB = syncDone;

      if (this._boxSynced) {
        this._onSyncDoneCB();
      }
    }
  }, {
    key: "_publishRootStore",
    value: function () {
      var _publishRootStore2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(rootStoreAddress) {
        var addressToken;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._3id.signJWT({
                  rootStoreAddress: rootStoreAddress
                });

              case 2:
                addressToken = _context7.sent;
                _context7.prev = 3;
                _context7.next = 6;
                return utils.fetchJson(this._serverUrl + '/odbAddress', {
                  address_token: addressToken
                });

              case 6:
                _context7.next = 12;
                break;

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](3);

                if (_context7.t0.statusCode) {
                  _context7.next = 12;
                  break;
                }

                throw new Error(_context7.t0);

              case 12:
                return _context7.abrupt("return", true);

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 8]]);
      }));

      function _publishRootStore(_x10) {
        return _publishRootStore2.apply(this, arguments);
      }

      return _publishRootStore;
    }()
    /**
     * @property {String} DID        the DID of the user
     */

  }, {
    key: "linkAddress",

    /**
     * Creates a proof that links an ethereum address to the 3Box account of the user. If given proof, it will simply be added to the root store.
     *
     * @param     {Object}    [link]                         Optional link object with type or proof
     * @param     {String}    [link.type='ethereum-eoa']     The type of link (default 'ethereum')
     * @param     {Object}    [link.proof]                   Proof object, should follow [spec](https://github.com/3box/3box/blob/master/3IPs/3ip-5.md)
     */
    value: function () {
      var _linkAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        var link,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                link = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};

                if (!link.proof) {
                  _context8.next = 5;
                  break;
                }

                _context8.next = 4;
                return this._writeAddressLink(link.proof);

              case 4:
                return _context8.abrupt("return");

              case 5:
                if (!(!link.type || link.type === ACCOUNT_TYPES.ethereumEOA)) {
                  _context8.next = 8;
                  break;
                }

                _context8.next = 8;
                return this._linkProfile();

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function linkAddress() {
        return _linkAddress.apply(this, arguments);
      }

      return linkAddress;
    }()
  }, {
    key: "linkAccount",
    value: function () {
      var _linkAccount = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9() {
        var type,
            _args9 = arguments;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                type = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : ACCOUNT_TYPES.ethereumEOA;
                console.warn('linkAccount: deprecated, please use linkAddress going forward');
                _context9.next = 4;
                return this.linkAddress(type);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function linkAccount() {
        return _linkAccount.apply(this, arguments);
      }

      return linkAccount;
    }()
    /**
     * Remove given address link, returns true if successful
     *
     * @param     {String}   address      address that is linked
     */

  }, {
    key: "removeAddressLink",
    value: function () {
      var _removeAddressLink = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(address) {
        var linkExist, payload, oneHour, deleteToken;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                address = address.toLowerCase();
                _context10.next = 3;
                return this.isAddressLinked({
                  address: address
                });

              case 3:
                linkExist = _context10.sent;

                if (linkExist) {
                  _context10.next = 6;
                  break;
                }

                throw new Error('removeAddressLink: link for given address does not exist');

              case 6:
                payload = {
                  address: address,
                  type: "delete-address-link"
                };
                oneHour = 60 * 60;
                _context10.next = 10;
                return this._3id.signJWT(payload, {
                  expiresIn: oneHour
                });

              case 10:
                deleteToken = _context10.sent;
                _context10.prev = 11;
                _context10.next = 14;
                return utils.fetchJson(this._serverUrl + '/linkdelete', {
                  delete_token: deleteToken
                });

              case 14:
                _context10.next = 20;
                break;

              case 16:
                _context10.prev = 16;
                _context10.t0 = _context10["catch"](11);

                if (_context10.t0.statusCode) {
                  _context10.next = 20;
                  break;
                }

                throw new Error(_context10.t0);

              case 20:
                _context10.next = 22;
                return this._deleteAddressLink(address);

              case 22:
                return _context10.abrupt("return", true);

              case 23:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[11, 16]]);
      }));

      function removeAddressLink(_x11) {
        return _removeAddressLink.apply(this, arguments);
      }

      return removeAddressLink;
    }()
    /**
     * Checks if there is a proof that links an external account to the 3Box account of the user. If not params given and any link exists, returns true
     *
     * @param     {Object}    [query]            Optional object with address and/or type.
     * @param     {String}    [query.type]       Does the given type of link exist
     * @param     {String}    [query.address]    Is the given adressed linked
     */

  }, {
    key: "isAddressLinked",
    value: function () {
      var _isAddressLinked = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11() {
        var query,
            links,
            linksQuery,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                query = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};
                if (query.address) query.address = query.address.toLowerCase();
                _context11.next = 4;
                return this._readAddressLinks();

              case 4:
                links = _context11.sent;
                linksQuery = links.find(function (link) {
                  var res = query.address ? link.address === query.address : true;
                  return query.type ? res && link.type === query.type : res;
                });
                return _context11.abrupt("return", Boolean(linksQuery));

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function isAddressLinked() {
        return _isAddressLinked.apply(this, arguments);
      }

      return isAddressLinked;
    }()
  }, {
    key: "isAccountLinked",
    value: function () {
      var _isAccountLinked = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12() {
        var type,
            _args12 = arguments;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                type = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : ACCOUNT_TYPES.ethereumEOA;
                console.warn('isAccountLinked: deprecated, please use isAddressLinked going forward');
                return _context12.abrupt("return", this.isAddressLinked(type));

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function isAccountLinked() {
        return _isAccountLinked.apply(this, arguments);
      }

      return isAccountLinked;
    }()
    /**
     * Lists address links associated with this 3Box
     *
     * @return    {Array}                        An array of link objects
     */

  }, {
    key: "listAddressLinks",
    value: function () {
      var _listAddressLinks = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13() {
        var entries;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._readAddressLinks();

              case 2:
                entries = _context13.sent;
                return _context13.abrupt("return", entries.reduce(function (list, entry) {
                  var item = Object.assign({}, entry);
                  item.linkId = item.entry.hash;
                  delete item.entry;
                  return item;
                }, []));

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function listAddressLinks() {
        return _listAddressLinks.apply(this, arguments);
      }

      return listAddressLinks;
    }()
  }, {
    key: "_linkProfile",
    value: function () {
      var _linkProfile2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14() {
        var address, linkData, did, consent;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                address = this._3id.managementAddress;
                _context14.next = 3;
                return this._readAddressLink(address);

              case 3:
                linkData = _context14.sent;

                if (linkData) {
                  _context14.next = 19;
                  break;
                }

                did = this.DID;
                _context14.prev = 6;
                _context14.next = 9;
                return utils.getLinkConsent(address, did, this._web3provider);

              case 9:
                consent = _context14.sent;
                _context14.next = 16;
                break;

              case 12:
                _context14.prev = 12;
                _context14.t0 = _context14["catch"](6);
                console.log(_context14.t0);
                throw new Error('Link consent message must be signed before adding data, to link address to store');

              case 16:
                linkData = {
                  version: 1,
                  type: ACCOUNT_TYPES.ethereumEOA,
                  message: consent.msg,
                  signature: consent.sig,
                  timestamp: consent.timestamp
                };
                _context14.next = 19;
                return this._writeAddressLink(linkData);

              case 19:
                _context14.next = 21;
                return this["public"].get('proof_did');

              case 21:
                if (_context14.sent) {
                  _context14.next = 29;
                  break;
                }

                _context14.t1 = this["public"];
                _context14.next = 25;
                return this._3id.signJWT();

              case 25:
                _context14.t2 = _context14.sent;
                _context14.t3 = {
                  noLink: true
                };
                _context14.next = 29;
                return _context14.t1.set.call(_context14.t1, 'proof_did', _context14.t2, _context14.t3);

              case 29:
                // Send consentSignature to 3box-address-server to link profile with ethereum address
                utils.fetchJson(this._serverUrl + '/link', linkData)["catch"](console.error);

              case 30:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[6, 12]]);
      }));

      function _linkProfile() {
        return _linkProfile2.apply(this, arguments);
      }

      return _linkProfile;
    }()
  }, {
    key: "_writeAddressLink",
    value: function () {
      var _writeAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15(proof) {
        var data, linkExist, link;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this._ipfs.dag.put(proof);

              case 2:
                data = _context15.sent.toBaseEncodedString();
                _context15.next = 5;
                return this._linkCIDExists(data);

              case 5:
                linkExist = _context15.sent;

                if (!linkExist) {
                  _context15.next = 8;
                  break;
                }

                return _context15.abrupt("return");

              case 8:
                link = {
                  type: 'address-link',
                  data: data
                };
                _context15.next = 11;
                return this._rootStore.add(link);

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function _writeAddressLink(_x12) {
        return _writeAddressLink2.apply(this, arguments);
      }

      return _writeAddressLink;
    }()
  }, {
    key: "_linkCIDExists",
    value: function () {
      var _linkCIDExists2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(cid) {
        var entries, linkEntries;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context16.sent;
                linkEntries = entries.filter(function (e) {
                  return e.payload.value.type === 'address-link';
                });
                return _context16.abrupt("return", linkEntries.find(function (entry) {
                  return entry.data === cid;
                }));

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function _linkCIDExists(_x13) {
        return _linkCIDExists2.apply(this, arguments);
      }

      return _linkCIDExists;
    }()
  }, {
    key: "_deleteAddressLink",
    value: function () {
      var _deleteAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(address) {
        var link;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                address = address.toLowerCase();
                _context17.next = 3;
                return this._readAddressLink(address);

              case 3:
                link = _context17.sent;

                if (link) {
                  _context17.next = 6;
                  break;
                }

                throw new Error('_deleteAddressLink: link for given address does not exist');

              case 6:
                return _context17.abrupt("return", this._rootStore.remove(link.entry.hash));

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _deleteAddressLink(_x14) {
        return _deleteAddressLink2.apply(this, arguments);
      }

      return _deleteAddressLink;
    }()
  }, {
    key: "_readAddressLinks",
    value: function () {
      var _readAddressLinks2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19() {
        var _this3 = this;

        var entries, linkEntries, resolveLinks;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context19.sent;
                linkEntries = entries.filter(function (e) {
                  return e.payload.value.type === 'address-link';
                });
                resolveLinks = linkEntries.map(
                /*#__PURE__*/
                function () {
                  var _ref6 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee18(entry) {
                    var obj;
                    return _regenerator["default"].wrap(function _callee18$(_context18) {
                      while (1) {
                        switch (_context18.prev = _context18.next) {
                          case 0:
                            _context18.next = 2;
                            return _this3._ipfs.dag.get(entry.payload.value.data);

                          case 2:
                            obj = _context18.sent.value;

                            if (obj.address) {
                              _context18.next = 7;
                              break;
                            }

                            _context18.next = 6;
                            return utils.recoverPersonalSign(obj.message, obj.signature);

                          case 6:
                            obj.address = _context18.sent;

                          case 7:
                            obj.entry = entry;
                            return _context18.abrupt("return", obj);

                          case 9:
                          case "end":
                            return _context18.stop();
                        }
                      }
                    }, _callee18);
                  }));

                  return function (_x15) {
                    return _ref6.apply(this, arguments);
                  };
                }());
                return _context19.abrupt("return", Promise.all(resolveLinks));

              case 6:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _readAddressLinks() {
        return _readAddressLinks2.apply(this, arguments);
      }

      return _readAddressLinks;
    }()
  }, {
    key: "_readAddressLink",
    value: function () {
      var _readAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee20(address) {
        var links;
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                address = address.toLowerCase();
                _context20.next = 3;
                return this._readAddressLinks();

              case 3:
                links = _context20.sent;
                return _context20.abrupt("return", links.find(function (link) {
                  return link.address.toLowerCase() === address;
                }));

              case 5:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function _readAddressLink(_x16) {
        return _readAddressLink2.apply(this, arguments);
      }

      return _readAddressLink;
    }()
  }, {
    key: "_ensurePinningNodeConnected",
    value: function () {
      var _ensurePinningNodeConnected2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee21(odbAddress, isThread) {
        var _this4 = this;

        var roomPeers, rootStoreAddress;
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this._ipfs.pubsub.peers(odbAddress);

              case 2:
                roomPeers = _context21.sent;

                if (!roomPeers.find(function (p) {
                  return p === _this4.pinningNode.split('/').pop();
                })) {
                  this._ipfs.swarm.connect(this.pinningNode, function () {});

                  rootStoreAddress = this._rootStore.address.toString();

                  if (isThread) {
                    this._pubsub.publish(PINNING_ROOM, {
                      type: 'SYNC_DB',
                      odbAddress: odbAddress,
                      thread: true
                    });
                  } else {
                    this._pubsub.publish(PINNING_ROOM, {
                      type: 'PIN_DB',
                      odbAddress: rootStoreAddress
                    });
                  }
                }

              case 4:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function _ensurePinningNodeConnected(_x17, _x18) {
        return _ensurePinningNodeConnected2.apply(this, arguments);
      }

      return _ensurePinningNodeConnected;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee22() {
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this._orbitdb.stop();

              case 2:
                _context22.next = 4;
                return this._pubsub.disconnect();

              case 4:
                globalOrbitDB = null;

              case 5:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Closes the 3box instance and clears local cache. If you call this,
     * users will need to sign a consent message to log in the next time
     * you call openBox.
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee23() {
        var address;
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.close();

              case 2:
                this._3id.logout();

                address = this._3id.managementAddress;
                localstorage.remove('linkConsent_' + address);

              case 5:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
    /**
     * Check if the given address is logged in
     *
     * @param     {String}    address                 An ethereum address
     * @return    {Boolean}                           true if the user is logged in
     */

  }, {
    key: "DID",
    get: function get() {
      return this._3id.muportDID;
    }
  }], [{
    key: "getProfile",
    value: function () {
      var _getProfile = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee24(address) {
        var opts,
            metadata,
            profile,
            normalizedAddress,
            _args24 = arguments;
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                opts = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : {};
                metadata = opts.metadata;
                opts = Object.assign({
                  useCacheService: true
                }, opts);

                if (!opts.useCacheService) {
                  _context24.next = 9;
                  break;
                }

                _context24.next = 6;
                return API.getProfile(address, opts.profileServer, {
                  metadata: metadata
                });

              case 6:
                profile = _context24.sent;
                _context24.next = 15;
                break;

              case 9:
                if (!metadata) {
                  _context24.next = 11;
                  break;
                }

                throw new Error('getting metadata is not yet supported outside of the API');

              case 11:
                normalizedAddress = address.toLowerCase();
                _context24.next = 14;
                return this._getProfileOrbit(normalizedAddress, opts);

              case 14:
                profile = _context24.sent;

              case 15:
                return _context24.abrupt("return", profile);

              case 16:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getProfile(_x19) {
        return _getProfile.apply(this, arguments);
      }

      return getProfile;
    }()
    /**
     * Get a list of public profiles for given addresses. This relies on 3Box profile API.
     *
     * @param     {Array}     address                 An array of ethereum addresses
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with each key an address and value the profile
     */

  }, {
    key: "getProfiles",
    value: function () {
      var _getProfiles = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee25(addressArray) {
        var opts,
            _args25 = arguments;
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                opts = _args25.length > 1 && _args25[1] !== undefined ? _args25[1] : {};
                return _context25.abrupt("return", API.getProfiles(addressArray, opts));

              case 2:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25);
      }));

      function getProfiles(_x20) {
        return _getProfiles.apply(this, arguments);
      }

      return getProfiles;
    }()
    /**
     * Get the public data in a space of a given address with the given name
     *
     * @param     {String}    address                 An ethereum address
     * @param     {String}    name                    A space name
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the public space data
     */

  }, {
    key: "getSpace",
    value: function () {
      var _getSpace = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee26(address, name) {
        var opts,
            _args26 = arguments;
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                opts = _args26.length > 2 && _args26[2] !== undefined ? _args26[2] : {};
                return _context26.abrupt("return", API.getSpace(address, name, opts.profileServer, opts));

              case 2:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26);
      }));

      function getSpace(_x21, _x22) {
        return _getSpace.apply(this, arguments);
      }

      return getSpace;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    space                   The name of the space the thread is in
     * @param     {String}    name                    The name of the thread
     * @param     {String}    firstModerator          The DID (or ethereum address) of the first moderator
     * @param     {Boolean}   members                 True if only members are allowed to post
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThread",
    value: function () {
      var _getThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee27(space, name, firstModerator, members) {
        var opts,
            _args27 = arguments;
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                opts = _args27.length > 4 && _args27[4] !== undefined ? _args27[4] : {};
                return _context27.abrupt("return", API.getThread(space, name, firstModerator, members, opts));

              case 2:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27);
      }));

      function getThread(_x23, _x24, _x25, _x26) {
        return _getThread.apply(this, arguments);
      }

      return getThread;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    address                 The orbitdb-address of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThreadByAddress",
    value: function () {
      var _getThreadByAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee28(address) {
        var opts,
            _args28 = arguments;
        return _regenerator["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                opts = _args28.length > 1 && _args28[1] !== undefined ? _args28[1] : {};
                return _context28.abrupt("return", API.getThreadByAddress(address, opts));

              case 2:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28);
      }));

      function getThreadByAddress(_x27) {
        return _getThreadByAddress.apply(this, arguments);
      }

      return getThreadByAddress;
    }()
    /**
     * Get the configuration of a users 3Box
     *
     * @param     {String}    address                 The ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getConfig",
    value: function () {
      var _getConfig = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee29(address) {
        var opts,
            _args29 = arguments;
        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                opts = _args29.length > 1 && _args29[1] !== undefined ? _args29[1] : {};
                return _context29.abrupt("return", API.getConfig(address, opts));

              case 2:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29);
      }));

      function getConfig(_x28) {
        return _getConfig.apply(this, arguments);
      }

      return getConfig;
    }()
    /**
     * Get the names of all spaces a user has
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            an array with all spaces as strings
     */

  }, {
    key: "listSpaces",
    value: function () {
      var _listSpaces = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee30(address) {
        var opts,
            _args30 = arguments;
        return _regenerator["default"].wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                opts = _args30.length > 1 && _args30[1] !== undefined ? _args30[1] : {};
                return _context30.abrupt("return", API.listSpaces(address, opts.profileServer));

              case 2:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30);
      }));

      function listSpaces(_x29) {
        return _listSpaces.apply(this, arguments);
      }

      return listSpaces;
    }()
  }, {
    key: "_getProfileOrbit",
    value: function () {
      var _getProfileOrbit2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee32(address) {
        var opts,
            rootStoreAddress,
            usingGlobalIPFS,
            ipfs,
            orbitdb,
            cache,
            pinningNode,
            publicStore,
            rootStore,
            readyPromise,
            profileEntry,
            profile,
            closeAll,
            _args32 = arguments;
        return _regenerator["default"].wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                opts = _args32.length > 1 && _args32[1] !== undefined ? _args32[1] : {};

                if (!idUtils.isMuportDID(address)) {
                  _context32.next = 3;
                  break;
                }

                throw new Error('DID are supported in the cached version only');

              case 3:
                _context32.next = 5;
                return API.getRootStoreAddress(address.toLowerCase(), opts.addressServer);

              case 5:
                rootStoreAddress = _context32.sent;
                usingGlobalIPFS = false; // let usingGlobalOrbitDB = false

                if (!globalIPFS) {
                  _context32.next = 12;
                  break;
                }

                ipfs = globalIPFS;
                usingGlobalIPFS = true;
                _context32.next = 15;
                break;

              case 12:
                _context32.next = 14;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 14:
                ipfs = _context32.sent;

              case 15:
                if (globalOrbitDB) {
                  orbitdb = globalOrbitDB;
                  usingGlobalIPFS = true;
                } else {
                  cache = null; // (opts.iframeStore && !!cacheProxy) ? cacheProxy : null

                  orbitdb = new OrbitDB(ipfs, opts.orbitPath, {
                    cache: cache
                  });
                }

                pinningNode = opts.pinningNode || PINNING_NODE;
                ipfs.swarm.connect(pinningNode, function () {});
                publicStore = new PublicStore(orbitdb);

                if (!rootStoreAddress) {
                  _context32.next = 41;
                  break;
                }

                _context32.next = 22;
                return orbitdb.open(rootStoreAddress);

              case 22:
                rootStore = _context32.sent;
                readyPromise = new Promise(function (resolve, reject) {
                  rootStore.events.on('ready', resolve);
                });
                rootStore.load();
                _context32.next = 27;
                return readyPromise;

              case 27:
                if (rootStore.iterator({
                  limit: -1
                }).collect().length) {
                  _context32.next = 30;
                  break;
                }

                _context32.next = 30;
                return new Promise(function (resolve, reject) {
                  rootStore.events.on('replicate.progress', function (_x, _y, _z, num, max) {
                    if (num === max) {
                      rootStore.events.on('replicated', resolve);
                    }
                  });
                });

              case 30:
                profileEntry = rootStore.iterator({
                  limit: -1
                }).collect().find(function (entry) {
                  return entry.payload.value.odbAddress.split('.')[1] === 'public';
                });
                _context32.next = 33;
                return publicStore._load(profileEntry.payload.value.odbAddress);

              case 33:
                _context32.next = 35;
                return publicStore._sync();

              case 35:
                profile = publicStore.all();

                closeAll =
                /*#__PURE__*/
                function () {
                  var _ref7 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee31() {
                    return _regenerator["default"].wrap(function _callee31$(_context31) {
                      while (1) {
                        switch (_context31.prev = _context31.next) {
                          case 0:
                            _context31.next = 2;
                            return rootStore.close();

                          case 2:
                            _context31.next = 4;
                            return publicStore.close();

                          case 4:
                            // if (!usingGlobalOrbitDB) await orbitdb.stop()
                            if (!usingGlobalIPFS) {} // await ipfs.stop()


                          case 5:
                          case "end":
                            return _context31.stop();
                        }
                      }
                    }, _callee31);
                  }));

                  return function closeAll() {
                    return _ref7.apply(this, arguments);
                  };
                }(); // close but don't wait for it


                closeAll();
                return _context32.abrupt("return", profile);

              case 41:
                return _context32.abrupt("return", null);

              case 42:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32);
      }));

      function _getProfileOrbit(_x30) {
        return _getProfileOrbit2.apply(this, arguments);
      }

      return _getProfileOrbit;
    }()
    /**
     * GraphQL for 3Box profile API
     *
     * @param     {Object}    query               A graphQL query object.
     * @param     {Object}    opts                Optional parameters
     * @param     {String}    opts.graphqlServer  URL of graphQL 3Box profile service
     * @return    {Object}                        a json object with each key an address and value the profile
     */

  }, {
    key: "profileGraphQL",
    value: function () {
      var _profileGraphQL = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee33(query) {
        var opts,
            _args33 = arguments;
        return _regenerator["default"].wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                opts = _args33.length > 1 && _args33[1] !== undefined ? _args33[1] : {};
                return _context33.abrupt("return", API.profileGraphQL(query, opts.graphqlServer));

              case 2:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33);
      }));

      function profileGraphQL(_x31) {
        return _profileGraphQL.apply(this, arguments);
      }

      return profileGraphQL;
    }()
    /**
     * Verifies the proofs of social accounts that is present in the profile.
     *
     * @param     {Object}            profile                 A user profile object, received from the `getProfile` function
     * @return    {Object}                                    An object containing the accounts that have been verified
     */

  }, {
    key: "getVerifiedAccounts",
    value: function () {
      var _getVerifiedAccounts = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee34(profile) {
        return _regenerator["default"].wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                return _context34.abrupt("return", API.getVerifiedAccounts(profile));

              case 1:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34);
      }));

      function getVerifiedAccounts(_x32) {
        return _getVerifiedAccounts.apply(this, arguments);
      }

      return getVerifiedAccounts;
    }()
    /**
     * Opens the 3Box associated with the given address
     *
     * @param     {String}            address                 An ethereum address
     * @param     {ethereumProvider}  ethereumProvider        An ethereum provider
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node
     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object
     * @param     {String}            opts.addressServer      URL of the Address Server
     * @param     {String}            opts.contentSignature   A signature, provided by a client of 3box using the private keys associated with the given address, of the 3box consent message
     * @return    {Box}                                       the 3Box instance for the given address
     */

  }, {
    key: "openBox",
    value: function () {
      var _openBox = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee35(address, ethereumProvider) {
        var opts,
            ipfs,
            _3id,
            box,
            _args35 = arguments;

        return _regenerator["default"].wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                opts = _args35.length > 2 && _args35[2] !== undefined ? _args35[2] : {};
                _context35.t0 = globalIPFS;

                if (_context35.t0) {
                  _context35.next = 6;
                  break;
                }

                _context35.next = 5;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 5:
                _context35.t0 = _context35.sent;

              case 6:
                ipfs = _context35.t0;
                globalIPFS = ipfs;
                _context35.next = 10;
                return ThreeId.getIdFromEthAddress(address, ethereumProvider, ipfs, opts);

              case 10:
                _3id = _context35.sent;
                box = new Box(_3id, ethereumProvider, ipfs, opts);
                _context35.next = 14;
                return box._load(opts);

              case 14:
                return _context35.abrupt("return", box);

              case 15:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35);
      }));

      function openBox(_x33, _x34) {
        return _openBox.apply(this, arguments);
      }

      return openBox;
    }()
  }, {
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return ThreeId.isLoggedIn(address);
    }
  }]);
  return Box;
}();

function initIPFS(_x35, _x36, _x37) {
  return _initIPFS.apply(this, arguments);
}

function _initIPFS() {
  _initIPFS = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee36(ipfs, iframeStore, ipfsOptions) {
    return _regenerator["default"].wrap(function _callee36$(_context36) {
      while (1) {
        switch (_context36.prev = _context36.next) {
          case 0:
            // if (!ipfs && !ipfsProxy) throw new Error('No IPFS object configured and no default available for environment')
            if (!!ipfs && iframeStore) console.log('Warning: iframeStore true, orbit db cache in iframe, but the given ipfs object is being used, and may not be running in same iframe.');

            if (!ipfs) {
              _context36.next = 5;
              break;
            }

            return _context36.abrupt("return", ipfs);

          case 5:
            return _context36.abrupt("return", new Promise(function (resolve, reject) {
              ipfs = new IPFS(ipfsOptions || IPFS_OPTIONS);
              ipfs.on('error', function (error) {
                console.error(error);
                reject(error);
              });
              ipfs.on('ready', function () {
                return resolve(ipfs);
              });
            }));

          case 6:
          case "end":
            return _context36.stop();
        }
      }
    }, _callee36);
  }));
  return _initIPFS.apply(this, arguments);
}

Box.idUtils = idUtils;
module.exports = Box;