"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var HDNode = require('ethers').utils.HDNode;

var didJWT = require('did-jwt');

var DidDocument = require('ipfs-did-document');

var IpfsMini = require('ipfs-mini');

var localstorage = require('store');

var Identities = require('orbit-db-identity-provider');

var _require = require('3box-orbitdb-plugins'),
    OdbIdentityProvider = _require.OdbIdentityProvider;

Identities.addIdentityProvider(OdbIdentityProvider);

var registerResolver = require('3id-resolver');

var utils = require('../utils/index');

var Keyring = require('./keyring');

var config = require('../config.js');

var DID_METHOD_NAME = '3';
var STORAGE_KEY = 'serialized3id_';
var MUPORT_IPFS = {
  host: config.muport_ipfs_host,
  port: config.muport_ipfs_port,
  protocol: config.muport_ipfs_protocol
};

var ThreeId =
/*#__PURE__*/
function () {
  function ThreeId(serializeState, ethereum, ipfs, opts) {
    (0, _classCallCheck2["default"])(this, ThreeId);
    this._ethereum = ethereum;
    this._ipfs = ipfs;
    this._keyrings = {};

    this._initKeys(serializeState, opts);

    registerResolver(ipfs);
    localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
  }

  (0, _createClass2["default"])(ThreeId, [{
    key: "signJWT",
    value: function () {
      var _signJWT = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(payload) {
        var _ref,
            use3ID,
            space,
            expiresIn,
            keyring,
            issuer,
            settings,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, use3ID = _ref.use3ID, space = _ref.space, expiresIn = _ref.expiresIn;
                keyring = space ? this._keyrings[space] : this._mainKeyring;
                issuer = this.muportDID;

                if (use3ID) {
                  issuer = this.DID;
                } else if (space) {
                  issuer = this._subDIDs[space];
                }

                settings = {
                  signer: keyring.getJWTSigner(),
                  issuer: issuer,
                  expiresIn: expiresIn
                };
                return _context.abrupt("return", didJWT.createJWT(payload, settings));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function signJWT(_x) {
        return _signJWT.apply(this, arguments);
      }

      return signJWT;
    }()
  }, {
    key: "getSubDID",
    value: function getSubDID(space) {
      return this._subDIDs[space];
    }
  }, {
    key: "getOdbId",
    value: function () {
      var _getOdbId = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(space) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", Identities.createIdentity({
                  type: '3ID',
                  threeId: this,
                  space: space
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getOdbId(_x2) {
        return _getOdbId.apply(this, arguments);
      }

      return getOdbId;
    }()
  }, {
    key: "serializeState",
    value: function serializeState() {
      var _this = this;

      var stateObj = {
        managementAddress: this.managementAddress,
        seed: this._mainKeyring.serialize(),
        spaceSeeds: {}
      };
      Object.keys(this._keyrings).map(function (name) {
        stateObj.spaceSeeds[name] = _this._keyrings[name].serialize();
      });
      return JSON.stringify(stateObj);
    }
  }, {
    key: "_initKeys",
    value: function _initKeys(serializeState) {
      var _this2 = this;

      var state = JSON.parse(serializeState); // TODO remove toLowerCase() in future, should be sanitized elsewhere
      //      this forces existing state to correct state so that address <->
      //      rootstore relation holds

      this.managementAddress = state.managementAddress.toLowerCase();
      this._mainKeyring = new Keyring(state.seed);
      Object.keys(state.spaceSeeds).map(function (name) {
        _this2._keyrings[name] = new Keyring(state.spaceSeeds[name]);
      });
    }
  }, {
    key: "_initDID",
    value: function () {
      var _initDID2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(muportIpfs) {
        var _this3 = this;

        var muportPromise, spaces, subDIDs;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                muportPromise = this._initMuport(muportIpfs);
                _context3.next = 3;
                return this._init3ID();

              case 3:
                this._rootDID = _context3.sent;
                spaces = Object.keys(this._keyrings);
                _context3.next = 7;
                return Promise.all(spaces.map(function (space) {
                  return _this3._init3ID(space);
                }));

              case 7:
                subDIDs = _context3.sent;
                this._subDIDs = {};
                spaces.map(function (space, i) {
                  _this3._subDIDs[space] = subDIDs[i];
                });
                _context3.next = 12;
                return muportPromise;

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _initDID(_x3) {
        return _initDID2.apply(this, arguments);
      }

      return _initDID;
    }()
  }, {
    key: "_init3ID",
    value: function () {
      var _init3ID2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(spaceName) {
        var doc, pubkeys, _pubkeys, payload, signature;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                doc = new DidDocument(this._ipfs, DID_METHOD_NAME);

                if (spaceName) {
                  _context4.next = 9;
                  break;
                }

                pubkeys = this._mainKeyring.getPublicKeys(true);
                doc.addPublicKey('signingKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);
                doc.addPublicKey('encryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);
                doc.addPublicKey('managementKey', 'Secp256k1VerificationKey2018', 'ethereumAddress', this.managementAddress);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'signingKey');
                _context4.next = 20;
                break;

              case 9:
                _pubkeys = this._keyrings[spaceName].getPublicKeys(true);
                doc.addPublicKey('subSigningKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', _pubkeys.signingKey);
                doc.addPublicKey('subEncryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', _pubkeys.asymEncryptionKey);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'subSigningKey');
                doc.addCustomProperty('space', spaceName);
                doc.addCustomProperty('root', this.DID);
                payload = {
                  subSigningKey: _pubkeys.signingKey,
                  subEncryptionKey: _pubkeys.asymEncryptionKey,
                  space: spaceName,
                  iat: null
                };
                _context4.next = 18;
                return this.signJWT(payload, {
                  use3ID: true
                });

              case 18:
                signature = _context4.sent.split('.')[2];
                doc.addCustomProperty('proof', {
                  alg: 'ES256K',
                  signature: signature
                });

              case 20:
                _context4.next = 22;
                return doc.commit({
                  noTimestamp: true
                });

              case 22:
                return _context4.abrupt("return", doc.DID);

              case 23:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _init3ID(_x4) {
        return _init3ID2.apply(this, arguments);
      }

      return _init3ID;
    }()
  }, {
    key: "_initMuport",
    value: function () {
      var _initMuport2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(muportIpfs) {
        var keys, doc, docHash, publishToInfura;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                keys = this._mainKeyring.getPublicKeys();
                doc = createMuportDocument(keys.signingKey, this.managementAddress, keys.asymEncryptionKey);
                _context6.next = 4;
                return this._ipfs.add(Buffer.from(JSON.stringify(doc)));

              case 4:
                docHash = _context6.sent[0].hash;
                this._muportDID = 'did:muport:' + docHash;
                this.muportFingerprint = utils.sha256Multihash(this.muportDID);

                publishToInfura =
                /*#__PURE__*/
                function () {
                  var _ref2 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee5() {
                    var ipfsMini;
                    return _regenerator["default"].wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            ipfsMini = new IpfsMini(muportIpfs);
                            ipfsMini.addJSON(doc, function (err, res) {
                              if (err) console.error(err);
                            });

                          case 2:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function publishToInfura() {
                    return _ref2.apply(this, arguments);
                  };
                }();

                publishToInfura();

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _initMuport(_x5) {
        return _initMuport2.apply(this, arguments);
      }

      return _initMuport;
    }()
  }, {
    key: "getKeyringBySpaceName",
    value: function getKeyringBySpaceName(name) {
      var split = name.split('.');

      if (split[0] === this.muportFingerprint) {
        return this._mainKeyring;
      } else {
        return this._keyrings[split[2]];
      }
    }
  }, {
    key: "initKeyringByName",
    value: function () {
      var _initKeyringByName = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(name) {
        var sig, entropy, seed;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this._keyrings[name]) {
                  _context7.next = 14;
                  break;
                }

                _context7.next = 3;
                return utils.openSpaceConsent(this.managementAddress, this._ethereum, name);

              case 3:
                sig = _context7.sent;
                entropy = '0x' + utils.sha256(sig.slice(2));
                seed = HDNode.mnemonicToSeed(HDNode.entropyToMnemonic(entropy));
                this._keyrings[name] = new Keyring(seed);
                _context7.next = 9;
                return this._init3ID(name);

              case 9:
                this._subDIDs[name] = _context7.sent;
                localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
                return _context7.abrupt("return", true);

              case 14:
                return _context7.abrupt("return", false);

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function initKeyringByName(_x6) {
        return _initKeyringByName.apply(this, arguments);
      }

      return initKeyringByName;
    }()
  }, {
    key: "logout",
    value: function logout() {
      localstorage.remove(STORAGE_KEY + this.managementAddress);
    }
  }, {
    key: "DID",
    get: function get() {
      return this._rootDID;
    }
  }, {
    key: "muportDID",
    get: function get() {
      return this._muportDID;
    }
  }], [{
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return Boolean(localstorage.get(STORAGE_KEY + address.toLowerCase()));
    }
  }, {
    key: "getIdFromEthAddress",
    value: function () {
      var _getIdFromEthAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(address, ethereum, ipfs) {
        var opts,
            normalizedAddress,
            serialized3id,
            sig,
            entropy,
            mnemonic,
            seed,
            _3id,
            _args8 = arguments;

        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : {};
                normalizedAddress = address.toLowerCase();
                serialized3id = localstorage.get(STORAGE_KEY + normalizedAddress);

                if (!serialized3id) {
                  _context8.next = 7;
                  break;
                }

                if (opts.consentCallback) opts.consentCallback(false);
                _context8.next = 19;
                break;

              case 7:
                if (!opts.contentSignature) {
                  _context8.next = 11;
                  break;
                }

                sig = opts.contentSignature;
                _context8.next = 14;
                break;

              case 11:
                _context8.next = 13;
                return utils.openBoxConsent(normalizedAddress, ethereum);

              case 13:
                sig = _context8.sent;

              case 14:
                if (opts.consentCallback) opts.consentCallback(true);
                entropy = '0x' + utils.sha256(sig.slice(2));
                mnemonic = HDNode.entropyToMnemonic(entropy);
                seed = HDNode.mnemonicToSeed(mnemonic);
                serialized3id = JSON.stringify({
                  managementAddress: normalizedAddress,
                  seed: seed,
                  spaceSeeds: {}
                });

              case 19:
                _3id = new ThreeId(serialized3id, ethereum, ipfs, opts);
                _context8.next = 22;
                return _3id._initDID(opts.muportIpfs || MUPORT_IPFS);

              case 22:
                return _context8.abrupt("return", _3id);

              case 23:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function getIdFromEthAddress(_x7, _x8, _x9) {
        return _getIdFromEthAddress.apply(this, arguments);
      }

      return getIdFromEthAddress;
    }()
  }]);
  return ThreeId;
}();

var createMuportDocument = function createMuportDocument(signingKey, managementKey, asymEncryptionKey) {
  return {
    version: 1,
    signingKey: signingKey,
    managementKey: managementKey,
    asymEncryptionKey: asymEncryptionKey
  };
};

module.exports = ThreeId;