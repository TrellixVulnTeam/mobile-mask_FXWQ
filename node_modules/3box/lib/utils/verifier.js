"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _require = require('./index'),
    fetchText = _require.fetchText,
    getMessageConsent = _require.getMessageConsent;

var didJWT = require('did-jwt');

var ethers = require('ethers');

require('https-did-resolver')["default"]();

require('muport-did-resolver')();

module.exports = {
  /**
   * Verifies that the gist contains the given muportDID and returns the users github username.
   * Throws an error otherwise.
   *
   * @param     {String}            did                     The muport DID of the user
   * @param     {Object}            gistUrl                 URL of the proof
   * @return    {Object}                                    Object containing username, and proof
   */
  verifyGithub: function () {
    var _verifyGithub = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(did, gistUrl) {
      var gistFileContent, username;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!gistUrl || gistUrl.trim() === '')) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", null);

            case 2:
              _context.next = 4;
              return fetchText(gistUrl);

            case 4:
              gistFileContent = _context.sent;

              if (!(gistFileContent.indexOf(did) === -1)) {
                _context.next = 7;
                break;
              }

              throw new Error('Gist File provided does not contain the correct DID of the user');

            case 7:
              username = gistUrl.split('/')[3];
              return _context.abrupt("return", {
                username: username,
                proof: gistUrl
              });

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function verifyGithub(_x, _x2) {
      return _verifyGithub.apply(this, arguments);
    }

    return verifyGithub;
  }(),

  /**
   * Verifies that the tweet contains the given muportDID and returns the users twitter username.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyTwitter: function () {
    var _verifyTwitter = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2(did, claim) {
      var verified, claimData;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (claim) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return", null);

            case 2:
              _context2.next = 4;
              return didJWT.verifyJWT(claim);

            case 4:
              verified = _context2.sent;

              if (!(verified.payload.sub !== did)) {
                _context2.next = 7;
                break;
              }

              throw new Error('Verification not valid for given user');

            case 7:
              claimData = verified.payload.claim;

              if (!(!claimData.twitter_handle || !claimData.twitter_proof)) {
                _context2.next = 10;
                break;
              }

              throw new Error('The claim for your twitter is not correct');

            case 10:
              return _context2.abrupt("return", {
                username: claimData.twitter_handle,
                proof: claimData.twitter_proof,
                verifiedBy: verified.payload.iss
              });

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function verifyTwitter(_x3, _x4) {
      return _verifyTwitter.apply(this, arguments);
    }

    return verifyTwitter;
  }(),

  /**
   * Verifies that the code entered by the user is the same one that was sent via email.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyEmail: function () {
    var _verifyEmail = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee3(did, claim) {
      var verified, claimData;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (claim) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", null);

            case 2:
              _context3.next = 4;
              return didJWT.verifyJWT(claim);

            case 4:
              verified = _context3.sent;

              if (!(verified.payload.sub !== did)) {
                _context3.next = 7;
                break;
              }

              throw new Error('Verification not valid for given user');

            case 7:
              claimData = verified.payload.claim;

              if (claimData.email_address) {
                _context3.next = 10;
                break;
              }

              throw new Error('The claim for your email address is not correct');

            case 10:
              return _context3.abrupt("return", {
                email_address: claimData.email_address,
                verifiedBy: verified.payload.iss
              });

            case 11:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function verifyEmail(_x5, _x6) {
      return _verifyEmail.apply(this, arguments);
    }

    return verifyEmail;
  }(),

  /**
   * Verifies that the proof for a did is correct
   *
   * @param     {String}            claim           A did-JWT with claim
   * @return    {String}                            The DID of the user
   */
  verifyDID: function () {
    var _verifyDID = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee4(claim) {
      var verified;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return didJWT.verifyJWT(claim);

            case 2:
              verified = _context4.sent;
              return _context4.abrupt("return", verified.payload.iss);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function verifyDID(_x7) {
      return _verifyDID.apply(this, arguments);
    }

    return verifyDID;
  }(),

  /**
   * Verifies that the proof for an ethereum address is correct
   *
   * @param     {Object}    ethProof                      The claim generated by getLinkConsent
   * @param     {string}    ethProof.consent_msg
   * @param     {string}    ethProof.consent_signature
   * @param     {string}    ethProof.linked_did
   * @param     {String}    did                           The box' did
   * @return    {String}                                  The ethereum address used to sign the message
   */
  verifyEthereum: function () {
    var _verifyEthereum = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee5(ethProof, did) {
      var consentMsg, consentSig, expected;
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              consentMsg = ethProof.version ? ethProof.message : ethProof['consent_msg'];
              consentSig = ethProof.version ? ethProof.signature : ethProof['consent_signature']; // Make sure the message matches our expectation

              expected = getMessageConsent(did);

              if (!(consentMsg !== expected)) {
                _context5.next = 5;
                break;
              }

              throw new Error("Invalid consent message, got: \"".concat(consentMsg, "\", expected: \"").concat(expected, "\""));

            case 5:
              return _context5.abrupt("return", ethers.utils.verifyMessage(consentMsg, consentSig));

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function verifyEthereum(_x8, _x9) {
      return _verifyEthereum.apply(this, arguments);
    }

    return verifyEthereum;
  }()
};