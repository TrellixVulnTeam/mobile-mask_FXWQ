"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _didJwt = require("did-jwt");

var _ipfsDidDocument = _interopRequireDefault(require("ipfs-did-document"));

var _base64url = _interopRequireDefault(require("base64url"));

var _didResolver = require("did-resolver");

var PUBKEY_IDS = ['signingKey', 'managementKey', 'encryptionKey'];
var SUB_PUBKEY_IDS = ['subSigningKey', 'subEncryptionKey'];

function register(ipfs) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _didResolver.registerMethod)('3', function (_, _ref) {
    var id = _ref.id;
    return resolve(ipfs, id);
  });
}

function resolve(_x, _x2, _x3) {
  return _resolve.apply(this, arguments);
}

function _resolve() {
  _resolve = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(ipfs, cid, isRoot) {
    var doc, rootDoc;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return _ipfsDidDocument["default"].cidToDocument(ipfs, cid);

          case 3:
            doc = _context.sent;
            validateDoc(doc);

            if (!doc.root) {
              _context.next = 14;
              break;
            }

            if (!isRoot) {
              _context.next = 8;
              break;
            }

            throw new Error('Only one layer subDoc allowed');

          case 8:
            _context.next = 10;
            return resolve(ipfs, doc.root.split(':')[2], true);

          case 10:
            rootDoc = _context.sent;
            _context.next = 13;
            return verifyProof(doc);

          case 13:
            doc = mergeDocuments(rootDoc, doc);

          case 14:
            _context.next = 26;
            break;

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](0);
            _context.prev = 18;
            _context.next = 21;
            return ipfs.pin.rm(cid);

          case 21:
            _context.next = 25;
            break;

          case 23:
            _context.prev = 23;
            _context.t1 = _context["catch"](18);

          case 25:
            throw new Error('Invalid 3ID');

          case 26:
            return _context.abrupt("return", doc);

          case 27:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 16], [18, 23]]);
  }));
  return _resolve.apply(this, arguments);
}

function validateDoc(doc) {
  var pubKeyIds = PUBKEY_IDS;

  if (!doc || !doc.publicKey || !doc.authentication) {
    throw new Error('Not a valid 3ID');
  }

  if (doc.root) {
    pubKeyIds = SUB_PUBKEY_IDS;
    if (!doc.space) throw new Error('Not a valid 3ID');
  }

  doc.publicKey.map(function (entry) {
    var id = entry.id.split('#')[1];
    if (!pubKeyIds.includes(id)) throw new Error('Not a valid 3ID');
  });
}

function encodeSection(data) {
  return _base64url["default"].encode(JSON.stringify(data));
}

function verifyProof(_x4) {
  return _verifyProof.apply(this, arguments);
}

function _verifyProof() {
  _verifyProof = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(subDoc) {
    var subSigningKey, subEncryptionKey, payload, header, jwt;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            subSigningKey = subDoc.publicKey.find(function (entry) {
              return entry.id.includes(SUB_PUBKEY_IDS[0]);
            }).publicKeyHex;
            subEncryptionKey = subDoc.publicKey.find(function (entry) {
              return entry.id.includes(SUB_PUBKEY_IDS[1]);
            }).publicKeyBase64;
            payload = encodeSection({
              iat: null,
              subSigningKey: subSigningKey,
              subEncryptionKey: subEncryptionKey,
              space: subDoc.space,
              iss: subDoc.root
            });
            header = encodeSection({
              typ: 'JWT',
              alg: subDoc.proof.alg
            });
            jwt = "".concat(header, ".").concat(payload, ".").concat(subDoc.proof.signature);
            _context2.next = 7;
            return (0, _didJwt.verifyJWT)(jwt);

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _verifyProof.apply(this, arguments);
}

function mergeDocuments(doc, subDoc) {
  subDoc.publicKey = doc.publicKey.concat(subDoc.publicKey);
  return subDoc;
}

module.exports = register;