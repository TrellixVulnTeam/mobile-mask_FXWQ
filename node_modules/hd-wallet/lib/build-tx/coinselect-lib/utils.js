"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inputBytes = inputBytes;
exports.outputBytes = outputBytes;
exports.dustThreshold = dustThreshold;
exports.transactionBytes = transactionBytes;
exports.uintOrNaN = uintOrNaN;
exports.bignumberOrNaN = bignumberOrNaN;
exports.sumOrNaN = sumOrNaN;
exports.getFee = getFee;
exports.finalize = finalize;
exports.anyOf = anyOf;
exports.utxoScore = utxoScore;

var _bignumber = _interopRequireDefault(require("bignumber.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// baseline estimates, used to improve performance
var TX_EMPTY_SIZE = 4 + 1 + 1 + 4 + 1; // 8 bytes start, 2 times 1 byte count in/out, 1 extra byte for segwit start

var TX_INPUT_BASE = 32 + 4 + 1 + 4;
var TX_OUTPUT_BASE = 8 + 1;

function inputBytes(input) {
  if (input.script.length == null) {
    throw new Error('Null script length');
  }

  return TX_INPUT_BASE + input.script.length;
}

function outputBytes(output) {
  if (output.script.length == null) {
    throw new Error('Null script length');
  }

  return TX_OUTPUT_BASE + output.script.length;
}

function dustThreshold(feeRate, inputLength, outputLength, explicitDustThreshold) {
  var size = transactionBytes([{
    script: {
      length: inputLength
    }
  }], [{
    script: {
      length: outputLength
    }
  }]);
  var price = size * feeRate;
  var threshold = Math.max(explicitDustThreshold, price);
  return threshold;
}

function transactionBytes(inputs, outputs) {
  return TX_EMPTY_SIZE + inputs.reduce(function (a, x) {
    return a + inputBytes(x);
  }, 0) + outputs.reduce(function (a, x) {
    return a + outputBytes(x);
  }, 0);
}

function uintOrNaN(v) {
  if (typeof v !== 'number') return NaN;
  if (!Number.isFinite(v)) return NaN;
  if (Math.floor(v) !== v) return NaN;
  if (v < 0) return NaN;
  return v;
}

function bignumberOrNaN(v) {
  if (v instanceof _bignumber["default"]) return v;
  if (typeof v !== 'string') return new _bignumber["default"](NaN);

  try {
    var value = new _bignumber["default"](v);
    return value.toFixed() === v && value.isInteger() ? value : new _bignumber["default"](NaN);
  } catch (error) {
    return new _bignumber["default"](NaN);
  }
}

function sumOrNaN(range) {
  var forgiving = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return range.reduce(function (a, x) {
    if (Number.isNaN(a)) return new _bignumber["default"](NaN);
    var value = bignumberOrNaN(x.value);
    if (value.isNaN()) return forgiving ? new _bignumber["default"](0).plus(a) : new _bignumber["default"](NaN);
    return value.plus(a);
  }, new _bignumber["default"](0));
} // DOGE fee policy https://github.com/dogecoin/dogecoin/issues/1650#issuecomment-722229742
// 1 DOGE base fee + 1 DOGE per every started kb + 1 DOGE for every output below 1 DOGE (dust limit)


function getFee(feeRate) {
  var bytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var outputs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var defaultFee = feeRate * bytes;
  var baseFee = options.baseFee || 0;

  if (baseFee && bytes) {
    if (options.floorBaseFee) {
      // increase baseFee for every started kb
      baseFee *= parseInt((baseFee + defaultFee) / baseFee, 10);
    } else {
      // simple increase baseFee
      baseFee += defaultFee;
    }
  }

  if (options.dustOutputFee) {
    // find all outputs below dust limit
    for (var i = 0; i < outputs.length; i++) {
      if (outputs[i].value && outputs[i].value - options.dustThreshold <= 0) {
        // increase for every output below dustThreshold
        baseFee += options.dustOutputFee;
      }
    }
  }

  return baseFee || defaultFee;
}

function finalize(inputs, outputsO, feeRate, options) {
  var inputLength = options.inputLength,
      changeOutputLength = options.changeOutputLength,
      explicitDustThreshold = options.dustThreshold;
  var outputs = outputsO;
  var bytesAccum = transactionBytes(inputs, outputs);
  var blankOutputBytes = outputBytes({
    script: {
      length: changeOutputLength
    }
  });
  var fee = getFee(feeRate, bytesAccum, options, outputs);
  var feeAfterExtraOutput = getFee(feeRate, bytesAccum + blankOutputBytes, options, outputs);
  var sumInputs = sumOrNaN(inputs);
  var sumOutputs = sumOrNaN(outputs); // if sum inputs/outputs is NaN
  // or `fee` is greater than sum of inputs reduced by sum of outputs (use case: baseFee)
  // no further calculation required (not enough funds)

  if (sumInputs.isNaN() || sumOutputs.isNaN() || sumInputs.minus(sumOutputs).lt(fee)) {
    return {
      fee: fee.toString()
    };
  }

  var remainderAfterExtraOutput = sumInputs.minus(sumOutputs.plus(feeAfterExtraOutput));
  var dust = dustThreshold(feeRate, inputLength, changeOutputLength, explicitDustThreshold); // is it worth a change output?

  if (remainderAfterExtraOutput.gt(dust)) {
    outputs = outputs.concat({
      value: remainderAfterExtraOutput.toString(),
      script: {
        length: changeOutputLength
      }
    });
  }

  return {
    inputs: inputs,
    outputs: outputs,
    fee: sumInputs.minus(sumOrNaN(outputs)).toString()
  };
}

function anyOf(algorithms) {
  return function (utxos, outputs, feeRate, inputLength, outputLength) {
    var result = {
      fee: Infinity
    };

    for (var i = 0; i < algorithms.length; i++) {
      var algorithm = algorithms[i];
      result = algorithm(utxos, outputs, feeRate, inputLength, outputLength);

      if (result.inputs) {
        return result;
      }
    }

    return result;
  };
}

function utxoScore(x, feeRate) {
  return new _bignumber["default"](x.value).minus(new _bignumber["default"](feeRate * inputBytes(x)));
}