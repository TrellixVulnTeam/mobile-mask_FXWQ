"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _didResolver = require("did-resolver");

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var INFURA = 'https://ipfs.infura.io/ipfs/';

function register(ipfs) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  function resolve(_x, _x2) {
    return _resolve.apply(this, arguments);
  }

  function _resolve() {
    _resolve = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(did, parsed) {
      var doc;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetchMuPortDoc(ipfs, parsed.id);

            case 2:
              doc = _context.sent;
              return _context.abrupt("return", wrapDocument(did, doc));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolve.apply(this, arguments);
  }

  (0, _didResolver.registerMethod)('muport', resolve);
}

function fetchMuPortDoc(_x3, _x4) {
  return _fetchMuPortDoc.apply(this, arguments);
}

function _fetchMuPortDoc() {
  _fetchMuPortDoc = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(ipfs, ipfsHash) {
    var doc;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;

            if (!ipfs) {
              _context2.next = 9;
              break;
            }

            _context2.t1 = JSON;
            _context2.next = 5;
            return ipfs.cat(ipfsHash);

          case 5:
            _context2.t2 = _context2.sent;
            _context2.t0 = _context2.t1.parse.call(_context2.t1, _context2.t2);
            _context2.next = 12;
            break;

          case 9:
            _context2.next = 11;
            return httpFetch(ipfsHash);

          case 11:
            _context2.t0 = _context2.sent;

          case 12:
            doc = _context2.t0;
            _context2.next = 17;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t3 = _context2["catch"](0);

          case 17:
            if (!(!doc || doc.version !== 1 || !doc.signingKey || !doc.managementKey || !doc.asymEncryptionKey)) {
              _context2.next = 20;
              break;
            }

            try {
              if (ipfs) ipfs.pin.rm(ipfsHash);
            } catch (e) {}

            throw new Error('Invalid muport did');

          case 20:
            return _context2.abrupt("return", doc);

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 15]]);
  }));
  return _fetchMuPortDoc.apply(this, arguments);
}

function httpFetch(_x5) {
  return _httpFetch.apply(this, arguments);
}

function _httpFetch() {
  _httpFetch = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee3(cid) {
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (0, _nodeFetch["default"])(INFURA + cid);

          case 2:
            return _context3.abrupt("return", _context3.sent.json());

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _httpFetch.apply(this, arguments);
}

function wrapDocument(did, muportDocument) {
  var doc = {
    "@context": "https://w3id.org/did/v1",
    "id": did,
    "publicKey": [{
      "id": did + "#signingKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did,
      "publicKeyHex": muportDocument.signingKey
    }, {
      "id": did + "#managementKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did
    }, {
      "id": did + "#encryptionKey",
      "type": "Curve25519EncryptionPublicKey",
      "owner": did,
      "publicKeyBase64": muportDocument.asymEncryptionKey
    }],
    "authentication": [{
      "type": "Secp256k1SignatureAuthentication2018",
      "publicKey": did + "#signingKey"
    }],
    "muportData": {}
  };

  if (muportDocument.managementKey.length === 42) {
    doc.publicKey[1].ethereumAddress = muportDocument.managementKey;
  } else {
    doc.publicKey[1].publicKeyHex = muportDocument.managementKey;
  }

  if (muportDocument.publicProfile) doc.uportProfile = muportDocument.publicProfile;
  if (muportDocument.symEncryptedData) doc.muportData.symEncryptedData = muportDocument.symEncryptedData;
  if (muportDocument.recoveryNetwork) doc.muportData.recoveryNetwork = muportDocument.recoveryNetwork;
  return doc;
}

module.exports = register;