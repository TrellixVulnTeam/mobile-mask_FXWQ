import { Boolean, Number, String, Literal, Record, Partial, Static } from 'runtypes';
export interface Features {
    bootloader_mode?: boolean | null;
    device_id: string | null;
    firmware_present?: boolean | null;
    fw_major?: number | null;
    fw_minor?: number | null;
    fw_patch?: number | null;
    major_version: number;
    minor_version: number;
    patch_version: number;
}
export interface StrictFeatures<MV extends Features['major_version'], BL extends Features['bootloader_mode'], FW extends Features['firmware_present'], FW_MV extends Features['fw_major'] = null> extends Features {
    major_version: MV;
    fw_major: FW_MV;
    fw_minor: FW_MV extends number ? number : null;
    fw_patch: FW_MV extends number ? number : null;
    bootloader_mode: BL;
    firmware_present: FW;
}
export declare const parseFeatures: (extFeatures: Features) => StrictFeatures<2, true, false, null> | StrictFeatures<2, null, null, null> | StrictFeatures<2, true, true, 2> | StrictFeatures<1, true, false, null> | StrictFeatures<1, true, true, null>;
declare const VersionArrayT2: import("runtypes").Tuple3<Literal<2>, Number, Number>;
declare const VersionArrayT1: import("runtypes").Tuple3<Literal<1>, Number, Number>;
declare const Release: import("runtypes").Intersect2<Record<{
    required: Boolean;
    url: String;
    fingerprint: String;
    changelog: String;
    min_bridge_version: import("runtypes").Tuple3<Number, Number, Number>;
    version: import("runtypes").Union2<import("runtypes").Tuple3<Literal<1>, Number, Number>, import("runtypes").Tuple3<Literal<2>, Number, Number>>;
    min_firmware_version: import("runtypes").Union2<import("runtypes").Tuple3<Literal<1>, Number, Number>, import("runtypes").Tuple3<Literal<2>, Number, Number>>;
    min_bootloader_version: import("runtypes").Union2<import("runtypes").Tuple3<Literal<1>, Number, Number>, import("runtypes").Tuple3<Literal<2>, Number, Number>>;
}, false>, Partial<{
    bootloader_version: import("runtypes").Union2<import("runtypes").Tuple3<Literal<1>, Number, Number>, import("runtypes").Tuple3<Literal<2>, Number, Number>>;
    url_bitcoinonly: String;
    fingerprint_bitcoinonly: String;
    notes: String;
    rollout: Number;
    channel: String;
}, false>>;
export declare type Release = Static<typeof Release>;
export declare type VersionArrayT1 = Static<typeof VersionArrayT1>;
export declare type VersionArrayT2 = Static<typeof VersionArrayT2>;
export declare type VersionArray = VersionArrayT1 | VersionArrayT2;
export declare const parseReleases: (extReleases: any) => Release[];
export {};
